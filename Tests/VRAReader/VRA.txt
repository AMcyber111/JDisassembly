writing this vary important function gave me a headake this is my algritham well i mays well say my name damian recoskie




//******************************where the start and end of the VRA is***********************************

//returns

//arg 1=disk position if disk position is -1 the read byte is null 00 hex

//arg 2=how much farther till reaching the end of the section data on disk but if position is -1 it shows the distance to the next section

public static long[] VraToPh(long VRA)
{
//distance to next vra

long NextVra=0;

//for calculating the positions

long l1=0x7FFFFFFFFFFFFFFFL;
long l2=0x7FFFFFFFFFFFFFFFL;

//the closest section and the section VRA lands in

int el1=(Map.length-4);
int el2=0;

//for calculating the absoulte end of the section used in loops for finding where vra is in

long end=0;

//used to calculte the phyisical section on disk drive

long StartPos=VRA;
long EndPos=0;
long ClostsPos=0;

//find the data that VRA lands in

for(;el1>-1;el1-=4){end=Map[el1]+Map[el1+1];if(Map[el1+1]<=VRA&VRA<end){break;}}

//find the closests section

end=0;for(int i=(Map.length-4);i>el1;){if((Map[i+1]>=VRA)&(Map[i+1]<l2)){l2=Map[i+1];el2=i;};i-=4;}
ClostsPos=Map[el2+1];

//if this address did not land in a section it is in a 00 byte area give back the distance to the closests section

if(el1>=0){StartPos=Map[el1+1];EndPos=(StartPos+Map[el1+2]);}else{return(new long[]{-1,ClostsPos-VRA});}

//is a nother section with in range of the data

if(l2!=0x7FFFFFFFFFFFFFFFL)
{
//then calculate if it overwites part of this section changing the read size of the section

if(ClostsPos>=StartPos&ClostsPos<=EndPos)
{
//modifyes where the actual end of section is because of over write

EndPos=ClostsPos;
NextVra=Map[el2+1];
}
//else still have not found any address

else{l2=0x7FFFFFFFFFFFFFFFL;}
}

//find any posable address that could be read next from this VRA

if(l2==0x7FFFFFFFFFFFFFFFL)
{
//scan for a address that may be less in position but if it whas over writen with a difrent section there may be data left of that section
//at the end of the over write if it whas over writen in the mid of a long section data that whas not over writen farther from the over write
//may still be there caculate any reming data

el2=Map.length-4;NextVra=VRA+(end-VRA);end=0;
for(;el2>-1;el2-=4){end=Map[el2]+Map[el2+1];if(Map[el2+1]<=NextVra&NextVra<end){l2=0;break;}}
}

//this section is no longer used it created errors in reading
//if there is no overlap or starting Vra scan for addreses farther away and give the length to the next section

//if(l2==0x7FFFFFFFFFFFFFFFL)
//{
//end=0;for(int i=(Map.length-4);i>-1;){if((Map[i+1]>=NextVra)&(Map[i+1]<l2)){l2=Map[i+1];NextVra=Map[i+1];};i-=4;}
//}

StartPos=((VRA-StartPos)+Map[el1+3]);EndPos=(EndPos-VRA);

//if the end of a section whas reached but a section is reacable from farther away

if(EndPos<=0){StartPos=-1;EndPos=(NextVra-VRA);}

//return the phyiscal address on disk and the read length limitation due to meny causes

return(new long[]{StartPos,EndPos});

}


i naver had to dump the sections to ram with my amzing algritham whiy must i calculate where thay end and continue so i can buffer read the
file and increses the speed for my io functions for decoding exe files and dlls and drivers

this algritham is flawless in ram address emulation but there still is a problem if the ram dump size is bigger and the disk read length is shorter
the undifined data length remaining to the section has to be calculated but it dose some how aotmaticaly scan that the section is empty
so my agritham is litarly a amazing problem solving toll for making the disk drive act as ram addresses

the section thought is should i use it to remap the sections in to there broken and layed sections in to a new array map to increse reading speed ?

but by standard there is normaly no more than 16 sections so i might just stick with the algritham instead of deconvertig where things break up in to the

maped sections array so less calculation is going on but it will not make a big diffrence but what makes a big diffrence is the buffer reading

here is what the function looks like after i compacted it

public static long[] VraToPh(long VRA){long NextVra=0,l1=0x7FFFFFFFFFFFFFFFL,l2=0x7FFFFFFFFFFFFFFFL,end=0,StartPos=VRA,EndPos=0,ClostsPos=0;
int el1=(Map.length-4),el2=0;for(;el1>-1;el1-=4){end=Map[el1]+Map[el1+1];if(Map[el1+1]<=VRA&VRA<end){break;}}
end=0;for(int i=(Map.length-4);i>el1;){if((Map[i+1]>=VRA)&(Map[i+1]<l2)){l2=Map[i+1];el2=i;};i-=4;};ClostsPos=Map[el2+1];
if(el1>=0){StartPos=Map[el1+1];EndPos=(StartPos+Map[el1+2]);}else{return(new long[]{-1,ClostsPos-VRA});}
if(l2!=0x7FFFFFFFFFFFFFFFL){if(ClostsPos>=StartPos&ClostsPos<=EndPos){EndPos=ClostsPos;NextVra=Map[el2+1];}else{l2=0x7FFFFFFFFFFFFFFFL;}}
if(l2==0x7FFFFFFFFFFFFFFFL){el2=Map.length-4;NextVra=VRA+(end-VRA);end=0;for(;el2>-1;el2-=4){end=Map[el2]+Map[el2+1];
if(Map[el2+1]<=NextVra&NextVra<end){l2=0;break;}}};StartPos=((VRA-StartPos)+Map[el1+3]);EndPos=(EndPos-VRA);
if(EndPos<=0){StartPos=-1;EndPos=(NextVra-VRA);};return(new long[]{StartPos,EndPos});}

and another optimiztion i could do is instead of seting l1 and l2 max qword singifyed interger size it would make the code simpler if it is -1 as
a check value instead of 7FFFFFFFFFFFFFFF hex

apply new optimiztions

public static long[] VraToPh(long VRA)
{
//distance to next vra

long NextVra=0;

//for calculating the positions

long l1=-1;
long l2=-1;

//the closest section and the section VRA lands in

int el1=(Map.length-4);
int el2=0;

//for calculating the absoulte end of the section used in loops for finding where vra is in

long end=0;

//used to calculte the phyisical section on disk drive

long StartPos=VRA;
long EndPos=0;
long ClostsPos=0;

//find the data that VRA lands in

for(;el1>-1;el1-=4){end=Map[el1]+Map[el1+1];if(Map[el1+1]<=VRA&VRA<end){break;}}

//find the closests section

end=0;for(int i=(Map.length-4);i>el1;){if((Map[i+1]>=VRA)&(Map[i+1]<l2)){l2=Map[i+1];el2=i;};i-=4;}
ClostsPos=Map[el2+1];

//if this address did not land in a section it is in a 00 byte area give back the distance to the closests section

if(el1>=0){StartPos=Map[el1+1];EndPos=(StartPos+Map[el1+2]);}else{return(new long[]{-1,ClostsPos-VRA});}

//is a nother section with in range of the data

if(l2!=-1)
{
//then calculate if it overwites part of this section changing the read size of the section

if(ClostsPos>=StartPos&ClostsPos<=EndPos)
{
//modifyes where the actual end of section is because of over write

EndPos=ClostsPos;
NextVra=Map[el2+1];
}
//else still have not found any address

else{l2=-1;}
}

//find any posable address that could be read next from this VRA

if(l2==-1)
{
//scan for a address that may be less in position but if it whas over writen with a difrent section there may be data left of that section
//at the end of the over write if it whas over writen in the mid of a long section data that whas not over writen farther from the over write
//may still be there caculate any reming data

el2=Map.length-4;NextVra=VRA+(end-VRA);end=0;
for(;el2>-1;el2-=4){end=Map[el2]+Map[el2+1];if(Map[el2+1]<=NextVra&NextVra<end){l2=0;break;}}
}

StartPos=((VRA-StartPos)+Map[el1+3]);EndPos=(EndPos-VRA);

//if the end of a section whas reached but a section is reacable from farther away

if(EndPos<=0){StartPos=-1;EndPos=(NextVra-VRA);}

//return the phyiscal address on disk and the read length limitation due to meny causes

return(new long[]{StartPos,EndPos});

}

then this is the compact version of this vary important function

//******************************where the start and end of the VRA is***********************************

public static long[] VraToPh(long VRA){int el1=(Map.length-4),el2=0;
long NextVra=0,l1=0x7FFFFFFFFFFFFFFFL,l2=0x7FFFFFFFFFFFFFFFL,end=0,StartPos=VRA,EndPos=0,ClostsPos=0;
for(;el1>-1;el1-=4){end=Map[el1]+Map[el1+1];if(Map[el1+1]<=VRA&VRA<end){break;}}
end=0;for(int i=(Map.length-4);i>el1;i-=4){if((Map[i+1]>=VRA)&(Map[i+1]<l2)){l2=Map[i+1];el2=i;}}ClostsPos=Map[el2+1];
if(el1>=0){StartPos=Map[el1+1];EndPos=(StartPos+Map[el1+2]);}else{return(new long[]{-1,ClostsPos-VRA});}
if(l2!=0x7FFFFFFFFFFFFFFFL){if(ClostsPos>=StartPos&ClostsPos<=EndPos){EndPos=ClostsPos;NextVra=Map[el2+1];}
else{l2=0x7FFFFFFFFFFFFFFFL;}}if(l2==0x7FFFFFFFFFFFFFFFL){el2=Map.length-4;NextVra=VRA+(end-VRA);end=0;
for(;el2>-1;el2-=4){end=Map[el2]+Map[el2+1];if(Map[el2+1]<=NextVra&NextVra<end){l2=0;break;}}}
StartPos=((VRA-StartPos)+Map[el1+3]);EndPos=(EndPos-VRA);if(EndPos<=0){StartPos=-1;EndPos=(NextVra-VRA);
if(EndPos<0){EndPos=(Map[el1+1]+Map[el1])-VRA;}if(EndPos<0){EndPos=-1;}}return(new long[]{StartPos,EndPos});}

now all that is left is step cancelation and varible cancelation and loop combining to increse speed

affter step cancelation and varible cancelation it now looks like this

//******************************where the start and end of the VRA is***********************************

public static long[] VraToPh(long VRA){int el1=(Map.length-4),el2=0;
long NextVra=0,l1=0x7FFFFFFFFFFFFFFFL,end=0,StartPos=VRA,EndPos=0,ClostsPos=0;
for(;el1>-1;el1-=4){end=Map[el1]+Map[el1+1];if(Map[el1+1]<=VRA&VRA<end){break;}}
end=0;for(int i=(Map.length-4);i>el1;i-=4){if((Map[i+1]>=VRA)&(Map[i+1]<l1)){l1=Map[i+1];el2=i;}};ClostsPos=Map[el2+1];
if(el1>=0){StartPos=Map[el1+1];EndPos=(StartPos+Map[el1+2]);}else{return(new long[]{-1,ClostsPos-VRA});}
if(l1!=0x7FFFFFFFFFFFFFFFL){if(ClostsPos>=StartPos&ClostsPos<=EndPos){EndPos=ClostsPos;NextVra=Map[el2+1];}
else{l1=0x7FFFFFFFFFFFFFFFL;}}if(l1==0x7FFFFFFFFFFFFFFFL){el2=Map.length-4;NextVra=VRA+(end-VRA);end=0;
for(;el2>-1;el2-=4){end=Map[el2]+Map[el2+1];if(Map[el2+1]<=NextVra&NextVra<end){l1=0;break;}}}
StartPos=((VRA-StartPos)+Map[el1+3]);EndPos=(EndPos-VRA);if(EndPos<=0){StartPos=-1;EndPos=(NextVra-VRA);
if(EndPos<0){EndPos=(Map[el1+1]+Map[el1])-VRA;}if(EndPos<0){EndPos=-1;}};return(new long[]{StartPos,EndPos});}

the reader now looks like this added at 1:36 AM 30/04/2013

public class VraReader
{
//if vra is set read useing the maped ram to disk array

public static long[] Map=new long[0];

//start of testing code

public static void main(String[]args) throws Exception
{
AddVraPos(400,10,400,0);
AddVraPos(170,150,200,0);
AddVraPos(150,403,700,0);
DebugMap();
}

//************************used to check if the reading boundarys are corect*****************************

public static void DebugMap(){long[] l=new long[]{1,1};long pos=0;while(l[0]>0|l[1]>0){l=VraToPh(pos);
if(l[0]>0|l[1]>0){System.out.println("Ram Address="+pos+"");System.out.println("disk pos="+l[0]+"");
System.out.println("end pos="+l[1]+"\r\n");pos+=l[1];try{System.in.read();}catch(Exception e){}}}}

//*****************************************Reset the Map************************************************

public static void ResetVraReader(){Map=new long[0];}

//************************************set up the ram addresses******************************************

public static void AddVraPos(long DumpSize,long RamPos,long ReadSize,long DiskPos){long[] l=new long[Map.length+4];
for(int i=0;i<Map.length;l[i]=Map[i],i++);l[Map.length]=DumpSize;l[Map.length+1]=RamPos;l[Map.length+2]=ReadSize;
l[Map.length+3]=DiskPos;Map=l;}

//******************************where the start and end of the VRA is***********************************

public static long[] VraToPh(long VRA){int el1=(Map.length-4),el2=0;
long NextVra=0,l1=0x7FFFFFFFFFFFFFFFL,end=0,StartPos=VRA,EndPos=0,ClostsPos=0;
for(;el1>-1;el1-=4){end=Map[el1]+Map[el1+1];if(Map[el1+1]<=VRA&VRA<end){break;}}
end=0;for(int i=(Map.length-4);i>el1;i-=4){if((Map[i+1]>=VRA)&(Map[i+1]<l1)){l1=Map[i+1];el2=i;}};ClostsPos=Map[el2+1];
if(el1>=0){StartPos=Map[el1+1];EndPos=(StartPos+Map[el1+2]);}else{return(new long[]{-1,ClostsPos-VRA});}
if(l1!=0x7FFFFFFFFFFFFFFFL){if(ClostsPos>=StartPos&ClostsPos<=EndPos){EndPos=ClostsPos;NextVra=Map[el2+1];}
else{l1=0x7FFFFFFFFFFFFFFFL;}}if(l1==0x7FFFFFFFFFFFFFFFL){el2=Map.length-4;NextVra=VRA+(end-VRA);end=0;
for(;el2>-1;el2-=4){end=Map[el2]+Map[el2+1];if(Map[el2+1]<=NextVra&NextVra<end){l1=0;break;}}}
StartPos=((VRA-StartPos)+Map[el1+3]);EndPos=(EndPos-VRA);if(EndPos<=0){StartPos=-1;EndPos=(NextVra-VRA);
if(EndPos<0){EndPos=(Map[el1+1]+Map[el1])-VRA;}if(EndPos<0){EndPos=-1;}};return(new long[]{StartPos,EndPos});}

}